// 효율성 꽝
function solution(n) {
    const set = new Set();
    for(let i=2; i<=n**(1/2); i++){
        for(let j=i,k=2; j*k<=n; k++){
            set.add(j*k);
        }
    }
    return n-set.size-1;
}

// 정확성  테스트
// 테스트 1 〉	통과 (0.05ms, 30.1MB)
// 테스트 2 〉	통과 (0.11ms, 30.4MB)
// 테스트 3 〉	통과 (0.12ms, 30.2MB)
// 테스트 4 〉	통과 (0.22ms, 30.1MB)
// 테스트 5 〉	통과 (0.15ms, 30MB)
// 테스트 6 〉	통과 (3.20ms, 32.7MB)
// 테스트 7 〉	통과 (0.59ms, 30MB)
// 테스트 8 〉	통과 (2.93ms, 33MB)
// 테스트 9 〉	통과 (5.29ms, 33.6MB)
// 테스트 10 〉	통과 (117.66ms, 42.6MB)
// 테스트 11 〉	통과 (522.30ms, 72.4MB)
// 테스트 12 〉	통과 (115.78ms, 52.4MB)
// 효율성  테스트
// 테스트 1 〉	실패 (시간 초과)
// 테스트 2 〉	실패 (시간 초과)
// 테스트 3 〉	실패 (시간 초과)
// 테스트 4 〉	실패 (시간 초과)


function solution(n) {
    let answer = [];
    let arr = Array.from({length: n+1}, ()=>true); //0~10
    arr.splice(0, 2, false, false);  // 0, 1은 소수가 아니므로 false 처리
    for(let i=2; i<=n;i++){  // 2부터 n까지 i가 2일 경우
        if(arr[i]){
            for(let j=i*i;j<=n;j+=i){   // j는 2의 제곱
                arr[j]=false;
            }
        }
    }
    answer = arr.filter((v)=>v===true).length;
    return answer;
}

// 정확성  테스트
// 테스트 1 〉	통과 (0.09ms, 30.2MB)
// 테스트 2 〉	통과 (0.14ms, 30.2MB)
// 테스트 3 〉	통과 (0.21ms, 30.2MB)
// 테스트 4 〉	통과 (0.46ms, 30.3MB)
// 테스트 5 〉	통과 (0.26ms, 30.1MB)
// 테스트 6 〉	통과 (1.90ms, 30.3MB)
// 테스트 7 〉	통과 (0.63ms, 30.3MB)
// 테스트 8 〉	통과 (1.52ms, 30.3MB)
// 테스트 9 〉	통과 (3.84ms, 32.9MB)
// 테스트 10 〉	통과 (48.79ms, 34.7MB)
// 테스트 11 〉	통과 (202.34ms, 40.5MB)
// 테스트 12 〉	통과 (53.13ms, 35MB)
// 효율성  테스트
// 테스트 1 〉	통과 (153.24ms, 41.2MB)
// 테스트 2 〉	통과 (169.97ms, 40.7MB)
// 테스트 3 〉	통과 (153.25ms, 40.4MB)
// 테스트 4 〉	통과 (163.25ms, 39.9MB)